#ОООП

### Что такое ООП?
> ООП - методология программирования, основанная на представлении программного продукта в виде совокупности объектов,   
> каждый из которых является экземпляром конкретного класса.   
> ООП использует в качестве базовых элементов взаимодействие объектов.

### Что такое Объект?
> Объект - именнованная модель реальной сущности, обладающая конкретными значениями свойств и проявляющая свое поведение,  
> обладающий именем набор данных (полей и свойств объекта), физически находящихся в памяти компьютера,   
> и методов, имеющих доступ к ним. Объект -конкретный экземпляр класса

### Что такое классы и объекты в Java?
>Ответ: Класс — это шаблон или чертеж, из которого создаются объекты. 
>Объект — это экземпляр класса.   
>Именно ванная модель реальной сущности обладающая конкретными значениями свойств(поля объекта)   
>и проявляющая свое поведение(методы объекта)

### Что такое интерфейсы в Java маркерные интерфейсы?
> Когда их нужно применять когда в них нет необходимости каких преимущества и интерфейсов? 
> В каких случаях на предыдущих проектах вы сначала описывали интерфейс, а потом писали его имплементацию
> 
> Маркерные интерфейсы — это интерфейсы, которые не содержат методов или полей. 
> Они служат для передачи метаданных о классе.   
> Примеры таких интерфейсов в Java включают Serializable, Cloneable и Remote.
>
### Когда следует писать интерфейсы:
**Гибкость и Расширяемость**

>Модульный дизайн: Если ваш проект требует модульности и легко изменяемого кода, интерфейсы могут помочь  . 
>Они позволяют легко заменять реализации без изменения клиентского кода.  
>Интерфейсы как контракты: Интерфейсы задают контракт, который должен быть выполнен всеми реализациями.   
>Это особенно полезно, когда у вас есть несколько реализаций одной и той же функциональности.

**Инверсия зависимости (Dependency Inversion Principle):**
>Принцип SOLID: В соответствии с принципом инверсии зависимости (DIP) из набора SOLID, 
> высокоуровневые модули не должны зависеть от низкоуровневых модулей. Оба должны зависеть от абстракций (интерфейсов).  
>Внедрение зависимостей: При использовании Dependency Injection (DI) и Inversion of Control (IoC)  
> контейнеров интерфейсы позволяют легко внедрять зависимости и заменять их, упрощая тестирование и замену компонентов.

**Тестирование:**  
>Mock объекты: Интерфейсы упрощают создание mock-объектов и заглушек для юнит-тестирования.    
>Это позволяет тестировать компоненты в изоляции от их реальных зависимостей.  

**Полиморфизм:**  
>Разнообразие реализаций: Интерфейсы позволяют использовать полиморфизм, что дает возможность одной и той же функции 
>работать с объектами разных классов, реализующих один интерфейс.  

**Публичные API:**
>Проектирование API: Если вы проектируете публичное API, интерфейсы могут помочь отделить контракт от реализации,   
> что упрощает обновление и замену реализации без нарушения совместимости.

### Когда интерфейсы не нужны
>Простые сценарии , Малые проекты,Нет необходимости в полиморфизме,Отсутствие альтернативных реализаций

### Назовите основные принципы ООП.

>Принято считать, что объектно-ориентированное программирование строится на 4 основных принципах (раньше их было всего 3).   
> Эти принципы:   
>- (Абстракция)
>- Инкапсуляция
>- Наследование
>- Полиморфизм

### Что такое инкапсуляция ? 
>Инкапсуляция — это один из четырех основных принципов объектно-ориентированного программирования (ООП).   
>Этот принцип подразумевает объединение данных (полей) и методов, которые работают с этими данными,   
>в одном классе и сокрытие внутренних деталей реализации от внешнего мира. Это позволяет ограничить доступ к внутренним   
>состояниям объектов и обеспечить их защиту от некорректных изменений.

### Что полиморфизм? 

>Полиморфизм (от греческих слов "poly" - много, "morph" - форма) — это принцип объектно-ориентированного программирования (ООП),   
>который позволяет объектам разных типов быть обработанными единообразным образом.  
>В Java полиморфизм достигается через переопределение методов (overriding) и перегрузку методов (overloading).  
>Виды полиморфизма:
>- **Компиль-time** (статический) полиморфизм:
>Достигается с помощью перегрузки методов (method overloading).  
>Перегрузка методов позволяет создавать несколько методов с одинаковым именем, но с разными параметрами.
>- **Runtime** (динамический) полиморфизм:
>Достигается с помощью переопределения методов (method overriding).  
>Переопределение методов позволяет подклассам предоставлять конкретную реализацию метода  , 
>который уже определен в их суперклассе или интерфейсе.
> 
> В более общем смысле, концепцией полиморфизма является идея "один интерфейс,   
>множество методов". Это означает, что можно создать общий интерфейс для группы близких по смыслу действи

###SOLID

>Принципы SOLID — это набор пяти принципов объектно-ориентированного дизайна,   
которые помогают разработчикам создавать более гибкий, понятный и поддерживаемый код.   
Они включают в себя:
>
>- Single Responsibility Principle (SRP) — Принцип единственной ответственности  
>- Open/Closed Principle (OCP) — Принцип открытости/закрытости  
>- Liskov Substitution Principle (LSP) — Принцип подстановки Барбары Лисков  
>- Interface Segregation Principle (ISP) — Принцип разделения интерфейсов  
>- Dependency Inversion Principle (DIP) — Принцип инверсии зависимостей


>- Open/Closed Principle (OCP) — Принцип открытости/закрытости:  
Программные сущности должны быть открыты для расширения, но закрыты для изменения. Новую функциональность следует добавлять, не изменяя существующий код.
>
>- Liskov Substitution Principle (LSP) — Принцип подстановки Барбары Лисков:  
Объекты подклассов должны быть взаимозаменяемы с объектами суперклассов без нарушения поведения программы. Подкласс должен корректно расширять базовый класс.
>
>- Interface Segregation Principle (ISP) — Принцип разделения интерфейсов:
   >Клиенты не должны быть вынуждены зависеть от интерфейсов, которые они не используют.   
   >Лучше иметь несколько специализированных интерфейсов, чем один общий.
>
>- Dependency Inversion Principle (DIP) — Принцип инверсии зависимостей:  
   >Высокоуровневые модули не должны зависеть от низкоуровневых модулей.   
   >Оба должны зависеть от абстракций. Абстракции не должны зависеть от деталей. Детали должны зависеть от абстракций(интерфейсы).  