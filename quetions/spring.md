## Spring

###Что такое Spring Framework?
>По сути Spring Framework представляет собой просто контейнер внедрения зависимостей,
>с несколькими удобными слоями (например: доступ к базе данных, прокси, аспектно-ориентированное программирование, RPC, веб-инфраструктура MVC).  
>Это все позволяет вам быстрее и удобнее создавать Java-приложения.

### В чем разница между Spring Boot и Spring MVC? Или между Spring Boot и Spring Framework?Можете ли вы использовать их вместе в одном проекте?
>Spring Boot построен поверх Spring Framework.  
>Пример: Spring Framework предлагает вам возможность читать файлы свойств .properties из различных мест,  
>например, с помощью аннотаций @PropertySource. Он также предлагает вам возможность писать JSON REST контроллеры с помощью инфраструктуры Web MVC.  
>Проблема в том, что вы должны указать Spring откуда читать свойства приложения и правильно настроить веб-фреймворк,  
>например, для поддержки JSON. Spring Boot, с другой стороны, берет эти отдельные части и предварительно настраивает их для вас.

>Например:
>Он всегда автоматически ищет файлы application.properties в различных заранее определенных местах и ​​считывает их.
>Он всегда загружает встроенный Tomcat, поэтому вы можете сразу увидеть результаты написания ваших @RestControllers и начать писать веб-приложения.
>Он автоматически настраивает все для отправки / получения JSON, не беспокоясь о конкретных зависимостях Maven / Gradle.   
>Все,путем запуска основного метода в классе Java, который аннотируется аннотацией @SpringBootApplication.

### Инверсия управления и Внедрение зависимостей(Inversion of Control, IoC) Внедрение зависимостей (Dependency Injection, DI)
>Инверсия управления (Inversion of Control, IoC) - это более широкий принцип проектирования,  
>направленный на передачу контроля над созданием и управлением объектов от кода приложения к контейнеру или фреймворку.  
>Он способствует развитию свободной связи и модульного проектирования путем делегирования ответственности за создание и управление зависимостями внешнему объекту.

>Внедрение зависимостей (Dependency Injection, DI) -это специфическая реализация IoC, при которой зависимости “внедряются” в класс,  
>а не создаются внутри него. DI - это способ реализации IoC, позволяющий предоставлять зависимости из внешних источников,   
>например через параметры конструктора, методы-сеттеры или интерфейсы.

### Что такое бин в Spring Boot
>Бин” (“bean”) в Spring Boot - это объект Java, управляемый IoC-контейнером фреймворка Spring. Эти бины создаются,  
конфигурируются и управляются фреймворком Spring и обычно представляют собой компоненты или сервисы,  
используемые в приложении. Определяемые с помощью аннотаций или XML-конфигурации,  
бины автоматически соединяются между собой фреймворком Spring, что позволяет легко внедрять зависимости и создавать модульные приложени

### Жизненный цикл (не обязательно)

### Скоупы бинов 
>Бин-синглтон (Singleton Bean)  
Бин-прототип (Prototype Bean)  
Бин запроса (Request Bean)  
Бин сессии (Session Bean)  

### Как мы можем создать бин из нашего класса ? 

### Как основные аннотации есть для указания класса в качестве Spring-компонент ? 

### Как спринг находит наши аннотированные классы ? Для чего нужен Component Scan?
>Первый шаг для описания Spring Beans это добавление аннотации — @Component, или @Service, или @Repository.  
Однако, Spring ничего не знает об этих бинах, если он не знает где искать их.   
То, что скажет Spring где искать эти бины и называется Component Scan. В @ComponentScan вы указываете пакеты, которые должны сканироваться.  
@SpringBootApplication определяет автоматическое сканирование пакета, где находится класс Application
Всё будет в порядке, ваш код целиком находится в указанном пакете или его подпакетах.
Однако, если необходимый вам компонент находится в другом пакете,  
вы должны использовать дополнительно аннотацию @ComponentScan, где перечислите все дополнительные пакеты для сканирования

### Аннтотация @Autowired 

###  Как вы решаете какой бин инжектить, если у вас несколько подходящих бинов. (Р@Primary и @Qualifier?)


###  Что такое транзакция Как в Spring управляются транзакции?
>В Spring транзакции управляются с использованием аннотаций @Transactional.  
Эта аннотация может быть применена к методу или классу, указывая, что метод должен быть выполнен в рамках транзакции.

###   Какие типы транзакций поддерживаются в Spring?  

>Spring поддерживает несколько типов транзакций:  
>- PROPAGATION_REQUIRED: Создает новую транзакцию, если ее нет, или использует текущую, если она существует.
>- PROPAGATION_REQUIRES_NEW: Создает новую транзакцию всегда, не зависимо от наличия текущей.
>- PROPAGATION_NESTED: Вложенная транзакция в рамках текущей транзакции, если она существует.
>- PROPAGATION_SUPPORTS: Поддерживает текущую транзакцию, если она есть, или не использует транзакцию в противном случае.
>- PROPAGATION_NOT_SUPPORTED: Не использует текущую транзакцию.

###   Какие проблемы может решить использование транзакций в Spring?
>Использование транзакций в Spring помогает обеспечить атомарность, согласованность, изолированность и долговечность   
операций с базой данных. Эти свойства транзакций (ACID) гарантируют надежность данных и целостность операций.  
Какие аспекты нужно учитывать при работе с распределенными транзакциями в Spring?

###  В чём разница между @Controller и @RestController?
>@RestController = @Controller + @ResponseBody  
@RestController превращает помеченный класс в Spring-бин.   
Этот бин для конвертации входящих/исходящих данных использует Jackson message converter.  
Как правило целевые данные представлены в json или xml.

###  Почему иногда мы используем @ResponseBody, а иногда ResponseEntity? в конроллерах
>ResponseEntity необходим, только если мы хотим кастомизировать ответ,   
добавив к нему статус ответа. Во всех остальных случаях будем использовать @ResponseBody.  
```java
@GetMapping(value=”/resource”) 
@ResponseBody 
public Resource sayHello() { return resource; }

@PostMapping(value=”/resource”) 
public ResponseEntity createResource() { 
    ….
return ResponseEntity.created(resource).build(); 
}
```
>Стандартные HTTP коды статусов ответов, которые можно использовать.
200 — SUCCESS
201 — CREATED
404 — RESOURCE NOT FOUND
400 — BAD REQUEST
401 — UNAUTHORIZED
500 — SERVER ERROR

###  Можно ли передать в запросе один и тот же параметр несколько раз?
>http://localhost:8080/login?name=Ranga&name=Ravi&name=Sathish
Да, можно принять все значения, используя массив в методе контроллера
```java
public String method(@RequestParam(value="name") String[] names){   
}
```