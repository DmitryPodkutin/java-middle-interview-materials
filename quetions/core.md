#CORE

##Типы данных в Java

###  Какие типы дынных есть в Java ?

####Примитивные типы данных  
>Целочисленные типы данных:
>- byte: 8-битное целое число со знаком. Диапазон от -128 до 127.
>- short: 16-битное целое число со знаком. Диапазон от -32,768 до 32,767.
>- int: 32-битное целое число со знаком. Диапазон от -2^31 до 2^31 - 1.
>- long: 64-битное целое число со знаком. Диапазон от -2^63 до 2^63 - 1.  

> Числовые типы данных с плавающей точкой:  
>- float: 32-битное число с плавающей точкой одинарной точности.
>- double: 64-битное число с плавающей точкой двойной точности (рекомендуемый тип для работы с дробными числами в Java).

>Символьный тип данных:
>- char: 16-битный символ Unicode. Используется для хранения символов и поддерживает все символы Unicode.

>Логический тип данных:  
>- boolean: Логический тип данных, который может принимать значение true или false.

####Ссылочные типы данных

>**Классы:**  
>Классы, которые являются основными строительными блоками объектно-ориентированного программирования в Java.
>**Интерфейсы:**  
>Интерфейсы, которые определяют методы, которые классы должны реализовать.  
**Перечисления (Enum):**  
Специальный тип данных, который позволяет определять набор именованных констант.  
**Массивы:**  
Структуры данных, которые содержат фиксированное количество элементов одного типа.   
**Строки:**
String: Особый тип данных для хранения и работы со строками символов.    
**Примитивные типы-оболочки (Wrapper Classes):**  
>Классы, которые оборачивают примитивные типы данных (Integer, Double, Boolean, и т.д.),  
>обеспечивая дополнительные методы и функциональность.


### Чем отличаются примитивные типы данных от ссылочных типов данных в Java. К примеру В чем разница между int и Integer
>**Примитивные типы данных** - это базовые типы данных, встроенные в язык.   
> Они хранят свои значения непосредственно в памяти и не являются объектами. В Java существуют следующие примитивные типы данных  
> 
>**Ссылочные типы данных** - это объекты, которые содержат ссылку на область памяти,   
> где фактически хранятся данные. Они включают все классы, массивы, интерфейсы и перечисления.
> 
**Примитивные типы**
> Преимущества:
>- Быстрее доступ и манипуляция.
>- Меньший расход памяти.
> 
>Недостатки:
>- Ограниченная функциональность.
>- Невозможность использовать методы.
> 
**Ссылочные типы**  
> 
>Преимущества:
>- Более богатая функциональность (методы, можно использовать в коллекциях, таких как List, Map и т.д.).
>- Могут быть null, что позволяет легко инициализировать отсутствие значения. 
> 
> Недостатки:
>- Медленнее доступ и манипуляция из-за разыменования.
>- Больший расход памяти.

### Autoboxing в Java

Autoboxing в Java - это автоматическое преобразование примитивных типов данных в соответствующие обёртки и наоборот.   
Это удобная особенность, позволяющая работать с примитивными типами данных как с объектами.

#### Примеры использования Autoboxing:

Преобразование из примитивного типа в обёртку: 
   ```java
   int primitiveInt = 10;
   Integer wrapperInt = primitiveInt; // Автоматическое преобразование (Autoboxing)
   Integer valeu = 5;
```
Фактически преобразуется компилятором в Integer value = new Integer(10);.   
Это происходит благодаря механизму Autoboxing, который автоматически преобразует примитивный тип int в соответствующий объект типа Integer.   
Таким образом, создаётся новый объект Integer со значением 10, который затем присваивается переменной value.
  
В Java для значений типа Integer существует механизм называемый "кэшированием" (caching),   
который используется для значений в диапазоне от -128 до 127. Для этих значений Java сохраняет один экземпляр объекта Integer и   
при запросе этого же значения возвращает ссылку на уже существующий объект, а не создаёт новый объект каждый раз.   
Это сделано для оптимизации использования памяти и улучшения производительности.
```java
Integer a = 10;
Integer b = 10;
System.out.println(a == b); // Выводит true, так как это один и тот же объект из кэша

Integer x = 128;
Integer y = 128;
System.out.println(x == y); // Выводит false, так как это разные объекты
```

### Пул строк (string pool)
В Java существует концепция "пула строк" (string pool), который является механизмом для управления строковыми объектами в памяти.
```java
String str1 = "hello";
String str2 = "hello";
System.out.println(str1 == str2); // Выводит true, так как обе переменные ссылаются на один и тот же объект в пуле строк

```

```java
String str1 = "hello";
String str2 = new String("hello");

System.out.println(str1 == str2); // Выводит false, так как str2 ссылается на другой объект, созданный с помощью new

```


### Модификаторы доступа?

#### Таблица доступа

| Модификатор доступа применение к | Класс | Пакет | Подкласс | Весь проект |
|----------------------------------|-------|-------|----------|-------------|
| `public`                         | Да    | Да    | Да       | Да          |
| `protected`                      | Нет   | Да    | Да       | Нет         |
| `default`                        | Нет   | Да    | Нет      | Нет         |
| `private`                        | Нет   | Нет   | Нет      | Нет         |

#### Таблица видимости переменных

| Модификатор доступа | Внутри класса | Внутри пакета | Внутри подкласса | Из любого места |
|---------------------|----------------|---------------|------------------|-----------------|
| `public`            | Да             | Да            | Да               | Да              |
| `protected`         | Да             | Да            | Да               | Нет             |
| `default`           | Да             | Да            | Нет              | Нет             |
| `private`           | Да             | Нет           | Нет              | Нет             |
  
##
### Класс Object(Для чего он и какие у него основные методы)
#### Класс Object в Java
В Java класс `Object` является корневым классом для всех других классов. 
Это означает, что любой класс, явно или неявно, является наследником класса `Object`.   
Основная цель класса `Object` — предоставление базовой функциональности, которая необходима для всех объектов в Java.   
Он определяет несколько методов, которые могут быть переопределены и используются в различных контекстах.

### Основные методы класса Object
1.  ####`public boolean equals(Object obj)`
Этот метод используется для сравнения текущего объекта с другим   
По умолчанию, метод `equals` из класса `Object` проверяет, являются ли две ссылки на объекты одинаковыми 
(т.е. указывают на один и тот же объект). Обычно этот метод переопределяется для обеспечения корректного сравнения содержимого объектов.

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    MyClass myClass = (MyClass) obj;
    return someField == myClass.someField && Objects.equals(anotherField, myClass.anotherField);
}
```

2. ####`public int hashCode()`

Метод `hashCode` возвращает хэш-код для объекта. Хэш-код используется в хэш-таблицах, например, в `HashMap`.   
По умолчанию, метод `hashCode` возвращает целое число, зависящее от адреса памяти объекта.   
Обычно этот метод переопределяется вместе с методом `equals`.

```java
@Override
public int hashCode() {
    return Objects.hash(someField, anotherField);
}
```

3. #### `public String toString()`

Метод `toString` возвращает строковое представление объекта. 
По умолчанию, метод `toString` возвращает строку, состоящую из имени класса, знака `@` и хэш-кода объекта в шестнадцатеричном формате. Этот метод часто переопределяется для создания более информативного строкового представления объекта.

```java
@Override
public String toString() {
    return "MyClass{" +
            "someField=" + someField +
            ", anotherField='" + anotherField + '\'' +
            '}';
}
```

4. ####`protected Object clone() throws CloneNotSupportedException`

Метод `clone` создает и возвращает копию текущего объекта.   
По умолчанию, метод `clone` создает поверхностную копию объекта.   
Для использования этого метода, класс должен реализовывать интерфейс `Cloneable`.

```java
@Override
protected Object clone() throws CloneNotSupportedException {
    return super.clone();
}
```

###
### Контракт equals и hash.

#### Контракт метода `equals` в Java

Метод `equals` определяет, равен ли один объект другому. Контракт метода `equals` включает следующие требования:

 1.**Рефлексивность**: Объект должен быть равен самому себе.
   ```java
   x.equals(x) == true
   ````
 2.**Симметричность**: Если объект x равен объекту y, то и объект y должен быть равен объекту x.
   ```java
   x.equals(y) == y.equals(x)
   ````   

 3.**Транзитивность**: Если объект x равен объекту y, а объект y равен объекту z, то объект x должен быть равен объекту z.
   ```java
   if (x.equals(y) && y.equals(z)) {
        x.equals(z) == true
        }
   ````

 4.**Согласованность**: Многократные вызовы метода equals должны возвращать одно и то же значение,  
пока свойства объектов, участвующих в сравнении, не изменяются.
   ```java
  x.equals(y) == true
   ````

 5.**Сравнение с null**: Любой объект должен быть не равен null.
   ```java
  x.equals(null) == false
   ````

###
#### Контракт метода `hashCode` в Java

 1.**Согласованность**: Многократные вызовы метода `hashCode` для одного и того же объекта должны возвращать одно и то же значение,   
при условии, что никакие свойства объекта, влияющие на вычисление хэш-кода, не изменяются.
   ```java
   x.hashCode() == x.hashCode()
   ```
 2.**Согласованность с equals**: Если два объекта равны в соответствии с методом equals, их хэш-коды должны быть равны.
   ```java
 if (x.equals(y)) {
        x.hashCode() == y.hashCode()
        }
   ```
 3.**Обратное неравенство**: Если два объекта не равны в соответствии с методом equals, их хэш-коды не обязательно должны быть различными.   
Однако, различные хэш-коды для разных объектов могут улучшить производительность хэш-таблиц.
   ```java
if (!x.equals(y)) {
        x.hashCode() != y.hashCode()
        }
   ```

**Пример реализации  методов equals и hashCode**
```java
@Override
public boolean equals(Object o) {
if (this == o) return true; // Ссылки ссылаются на один объект
if (o == null || getClass() != o.getClass()) return false; // Проверка типа и наличия объекта
Person person = (Person) o; // Приведение типа объекта
return age == person.age && Objects.equals(name, person.name); // Сравнение полей объектов
}

    @Override
    public int hashCode() {
        return Objects.hash(name, age); // Вычисление хэш-кода на основе полей объекта
    }
```


###  Дженерики
Дженерики (Generics) в Java позволяют создавать классы, интерфейсы и методы, которые работают с различными типами данных,  
при этом сохраняя безопасность типов. Они позволяют писать более обобщенный и повторно используемый код.   

####Основные преимущества дженериков:
>Обнаружение ошибок во время компиляции, а не во время выполнения.  
>Устранение необходимости явного приведения типов.
>Повышение читаемости и документированности кода.  


#### Каковы основные синтаксические элементы дженериков в Java?
>Обобщенные классы и интерфейсы: class Box<T> { ... }  
>Обобщенные методы: <T> void add(T element) { ... }  
>Параметры типа: <T>, <E>, <K, V>  

#### Что такое ограничения типа (bounded type parameters) в дженериках? Приведите примеры.
>Ограничения типа позволяют задать верхнюю или нижнюю границу для параметров типа.   
>Это позволяет использовать методы и свойства определенного класса или интерфейса. 
**Примеры:**  
>Верхняя граница (upper bound): <T extends Number> – T должен быть подклассом Number.  
>Нижняя граница (lower bound): <T super Number> – T должен быть суперклассом Number.  


####Что такое wildcard и как он используется в дженериках? Приведите примеры.
>Wildcard (?) обозначает неизвестный тип. Существует три вида wildcards:  
>Неограниченный wildcard: List<?> – список с неизвестным типом.  
>Wildcard с верхней границей: List<? extends Number> – список, где тип является подклассом Number.  
>Wildcard с нижней границей: List<? super Integer> – список, где тип является суперклассом Integer  