### Коллекции

>Коллекции - это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с   
>целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, 
>поддерживающих три основные операции:
>добавление нового элемента в коллекцию;

- удаление элемента из коллекции;
- изменение элемента в коллекции.

#### Основные интерфейсы коллекций и их имплементации.
Сollection расширяет три интерфейса: List, Set, Queue.

>List - хранит упорядоченные елементы(могут быть одинаковые); 
> представляет собой саморасширяющуюся коллекцию в том смысле, что она автоматически увеличивает свою 
> ёмкость при добавлении элементов, а также позволяет эффективно работать с упорядоченными последовательностями данных.  
>Имеет такие реализации как LinkedList, ArrayList и Vector.  
>Vector синхронизирован, и по этому в одном потоке, он работает медленней остальных реализаций.  
>ArrayList - его преимущество в навигации по коллекции.  
>LinkedList - Его преимущество во вставке и удалении элементов в коллекции.

>Set - коллекции, которые не содержат повторяющихся элементов.
>Основные реализации: HashSet, TreeSet, LinkedHashSet
>TreeSet - упорядочивает элементы по их значениям;  
>HashSet - упорядочивает элементы по их хэш ключах, хотя на первый взляд может показаться что элементы хранятся в случайном порядке.
>LinkedHashSet - хранит элементы в порядке их добавления

>Queue - интерфейс для реализации очереди в джава.  
>Основные реализации: LinkedList, PriorityQueue.  
>Очереди работают по принципу FIFO – first in first out.  

>Map - интерфейс для реализации так называемой карты, ключ значение.   
>Основные реализации: HashTable, HashMap, TreeMap, LinkedHashMap  
>HashTable - синхронизированна, объявлена уставревшей.   
>HashMap - порядок елементов рассчитывается по хэш ключу;   
>TreeMap - элементы хранятся в отсортированном порядке   
>LinkedHashMap - элементы хранятся в порядке вставки 
>Ключи в Мар не могут быть одинаковыми! 


### Чем отличается ArrayList от LinkedList? В каких случаях лучше использовать первый, а в каких второй?

**ArrayList:**
>Внутреннее представление: Реализован как массив объектов.  
>Доступ к элементам: Прямой доступ по индексу (O(1)).  
Добавление/удаление элементов: Добавление и удаление в конец списка быстрое (O(1)),     
но добавление/удаление в середине или начале требует перемещения элементов (O(n)).  
Память: Занимает больше памяти из-за резервирования места для массива.  
Использование: Подходит для случаев, когда часто происходят операции доступа по индексу 
и приложение не требует частых вставок/удалений в середине списка.    
**LinkedList:**
Внутреннее представление: Реализован как двусвязный список.  
>Доступ к элементам: Доступ к элементам только последовательный (O(n)), нет прямого доступа по индексу.  
>Добавление/удаление элементов: Добавление и удаление элементов в любом месте списка быстрое (O(1)), так как требуется только изменение ссылок.  
>Память: Занимает больше памяти на хранение ссылок на следующий и предыдущий элементы.  
>Использование: Подходит для случаев, когда требуются частые операции вставки/удалени
> элементов в середине списка или требуется итерация по всем элементам.    
>
**Рекомендации по использованию:**  
>ArrayList используйте, когда:  
>Необходим быстрый доступ к элементам по индексу.  
>Часто происходят операции добавления/удаления элементов в конец списка.  
>Память не критична и можно заранее определить её размер.  
>LinkedList используйте, когда:  
>Часто требуются операции вставки/удаления элементов в середине списка.  
>Операции доступа по индексу не являются критически важными.  
>Важнее экономия памяти на хранение ссылок.  

### Можно ли итерироваться по коллекции и одновременно модифицировать ее (добавлять удалять элементы) 
>Да Есть Iterator представляет собой интерфейс, который позволяет последовательно   
>перебирать элементы коллекции и удалять их при необходимости. Пример использования:
```java
List<String> list = new ArrayList<>();
list.add("one");
list.add("two");

Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
    if (s.equals("two")) {
        iterator.remove(); // Безопасное удаление элемента
    }
}
```
###  Вопросы по MAP
#### Что такое интерфейс Map в Java? Какие основные реализации вы знаете? (Если мы не ответили на вопрос выше)
>Ответ: Map в Java представляет собой интерфейс, который отображает ключи на значения и не допускает дублирования ключей.   
>Основные реализации: HashMap, TreeMap, LinkedHashMap, ConcurrentHashMap.  

####  Чем отличается HashMap от TreeMap? В каких случаях лучше использовать каждую из них?
>Ответ: HashMap использует хеш-таблицу для хранения данных и обеспечивает O(1) сложность для операций добавления,   
>удаления и поиска в среднем случае. TreeMap использует красно-черное дерево и гарантирует элементы в отсортированном порядке по ключам.  
>HashMap предпочтительнее для большинства случаев, если не требуется строгая упорядоченность ключей.

####  Какие особенности у ConcurrentHashMap? В чем его отличие от HashMap?  
>Ответ: ConcurrentHashMap поддерживает безопасное параллельное доступ к коллекции.  
>В отличие от HashMap, он использует блокировки на уровне сегментов (buckets), что позволяет нескольким потокам   
>одновременно читать и изменять отдельные сегменты без блокировки всей коллекции.

####  Какие ключевые методы и особенности HashMap?
>Ответ: Основные методы HashMap включают put(key, value), get(key), remove(key), containsKey(key), size().  
>Особенности: хранение данных в виде ключ-значение, поддержка null в качестве ключа и значения, не гарантирует порядок элементов.  

###  Что такое коллизия в HashMap?
>Коллизия в HashMap возникает, когда два или более ключа после хеширования   
>совпадают и должны быть помещены в один и тот же "bucket" (ячейку массива).
> В HashMap используется метод цепочек (chaining). Каждая ячейка массива (bucket) содержит связанный список (linked list) доступ O(n)  
> или более эффективную структуру данных (например, красно-черное дерево начиная с Java 8 доступ log O(n)), чтобы хранить элементы с одинаковыми хешами.  
> Когда ключи коллизируют, новый элемент добавляется в конец соответствующего списка.  